{"/home/travis/build/npmtest/node-npmtest-influx/test.js":"/* istanbul instrument in package npmtest_influx */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-influx/lib.npmtest_influx.js":"/* istanbul instrument in package npmtest_influx */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_influx = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_influx = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-influx/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-influx && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_influx */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_influx\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_influx.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_influx.rollup.js'] =\n            local.assetsDict['/assets.npmtest_influx.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_influx.__dirname + '/lib.npmtest_influx.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-influx/node_modules/influx/lib/src/index.js":"\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar url = require(\"url\");\r\nvar b = require(\"./builder\");\r\nvar grammar = require(\"./grammar\");\r\nvar pool_1 = require(\"./pool\");\r\nvar results_1 = require(\"./results\");\r\nvar schema_1 = require(\"./schema\");\r\nvar defaultHost = Object.freeze({\r\n    host: '127.0.0.1',\r\n    port: 8086,\r\n    protocol: 'http',\r\n});\r\nvar defaultOptions = Object.freeze({\r\n    database: null,\r\n    hosts: [],\r\n    password: 'root',\r\n    schema: [],\r\n    username: 'root',\r\n});\r\n__export(require(\"./builder\"));\r\nvar grammar_1 = require(\"./grammar\");\r\nexports.FieldType = grammar_1.FieldType;\r\nexports.Precision = grammar_1.Precision;\r\nexports.Raw = grammar_1.Raw;\r\nexports.escape = grammar_1.escape;\r\nexports.toNanoDate = grammar_1.toNanoDate;\r\nvar results_2 = require(\"./results\");\r\nexports.ResultError = results_2.ResultError;\r\n/**\r\n * Parses the URL out into into a IClusterConfig object\r\n */\r\nfunction parseOptionsUrl(addr) {\r\n    var parsed = url.parse(addr);\r\n    var options = {\r\n        host: parsed.hostname,\r\n        port: Number(parsed.port),\r\n        protocol: parsed.protocol.slice(0, -1),\r\n    };\r\n    if (parsed.auth) {\r\n        _a = parsed.auth.split(':'), options.username = _a[0], options.password = _a[1];\r\n    }\r\n    if (parsed.pathname.length > 1) {\r\n        options.database = parsed.pathname.slice(1);\r\n    }\r\n    return options;\r\n    var _a;\r\n}\r\n/**\r\n * Works similarly to Object.assign, but only overwrites\r\n * properties that resolve to undefined.\r\n */\r\nfunction defaults(target) {\r\n    var srcs = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        srcs[_i - 1] = arguments[_i];\r\n    }\r\n    srcs.forEach(function (src) {\r\n        Object.keys(src).forEach(function (key) {\r\n            if (target[key] === undefined) {\r\n                target[key] = src[key];\r\n            }\r\n        });\r\n    });\r\n    return target;\r\n}\r\n/**\r\n * InfluxDB is the public interface to run queries against the your database.\r\n * This is a 'driver-level' module, not a a full-fleged ORM or ODM; you run\r\n * queries directly by calling methods on this class.\r\n *\r\n * Please check out some of [the tutorials](https://node-influx.github.io/manual/tutorial.html)\r\n * if you want help getting started!\r\n *\r\n * @example\r\n * const Influx = require('influx');\r\n * const influx = new Influx.InfluxDB({\r\n *  host: 'localhost',\r\n *  database: 'express_response_db',\r\n *  schema: [\r\n *    {\r\n *      measurement: 'response_times',\r\n *      fields: {\r\n *        path: Influx.FieldType.STRING,\r\n *        duration: Influx.FieldType.INTEGER\r\n *      },\r\n *      tags: [\r\n *        'host'\r\n *      ]\r\n *    }\r\n *  ]\r\n * })\r\n *\r\n * influx.writePoints([\r\n *   {\r\n *     measurement: 'response_times',\r\n *     tags: { host: os.hostname() },\r\n *     fields: { duration, path: req.path },\r\n *   }\r\n * ]).then(() => {\r\n *   return influx.query(`\r\n *     select * from response_times\r\n *     where host = ${Influx.escape.stringLit(os.hostname())}\r\n *     order by time desc\r\n *     limit 10\r\n *   `)\r\n * }).then(rows => {\r\n *   rows.forEach(row => console.log(`A request to ${row.path} took ${row.duration}ms`))\r\n * })\r\n */\r\nvar InfluxDB = (function () {\r\n    /**\r\n     * Connect to a single InfluxDB instance by specifying\r\n     * a set of connection options.\r\n     * @param {IClusterConfig|ISingleHostConfig|string} [options='http://root:root@127.0.0.1:8086']\r\n     *\r\n     * @example\r\n     * const Influx = require('influx')\r\n     *\r\n     * // Connect to a single host with a DSN:\r\n     * const influx = new Influx.InfluxDB('http://user:password@host:8086/database')\r\n     *\r\n     * @example\r\n     * const Influx = require('influx')\r\n     *\r\n     * // Connect to a single host with a full set of config details and\r\n     * // a custom schema\r\n     * const client = new Influx.InfluxDB({\r\n     *   database: 'my_db',\r\n     *   host: 'localhost',\r\n     *   port: 8086,\r\n     *   username: 'connor',\r\n     *   password: 'pa$$w0rd',\r\n     *   schema: [\r\n     *     {\r\n     *       measurement: 'perf',\r\n     *       fields: {\r\n     *         memory_usage: Influx.FieldType.INTEGER,\r\n     *         cpu_usage: Influx.FieldType.FLOAT,\r\n     *         is_online: Influx.FieldType.BOOLEAN\r\n     *       }\r\n     *       tags: [\r\n     *         'hostname'\r\n     *       ]\r\n     *     }\r\n     *   ]\r\n     * })\r\n     *\r\n     * @example\r\n     * const Influx = require('influx')\r\n     *\r\n     * // Use a pool of several host connections and balance queries across them:\r\n     * const client = new Influx.InfluxDB({\r\n     *   database: 'my_db',\r\n     *   username: 'connor',\r\n     *   password: 'pa$$w0rd',\r\n     *   hosts: [\r\n     *     { host: 'db1.example.com' },\r\n     *     { host: 'db2.example.com' },\r\n     *   ],\r\n     *   schema: [\r\n     *     {\r\n     *       measurement: 'perf',\r\n     *       fields: {\r\n     *         memory_usage: Influx.FieldType.INTEGER,\r\n     *         cpu_usage: Influx.FieldType.FLOAT,\r\n     *         is_online: Influx.FieldType.BOOLEAN\r\n     *       }\r\n     *       tags: [\r\n     *         'hostname'\r\n     *       ]\r\n     *     }\r\n     *   ]\r\n     * })\r\n     *\r\n     */\r\n    function InfluxDB(options) {\r\n        var _this = this;\r\n        /**\r\n         * Map of Schema instances defining measurements in Influx.\r\n         * @private\r\n         */\r\n        this.schema = Object.create(null);\r\n        // Figure out how to parse whatever we were passed in into a IClusterConfig.\r\n        if (typeof options === 'string') {\r\n            options = parseOptionsUrl(options);\r\n        }\r\n        else if (!options) {\r\n            options = defaultHost;\r\n        }\r\n        if (!options.hasOwnProperty('hosts')) {\r\n            options = {\r\n                database: options.database,\r\n                hosts: [options],\r\n                password: options.password,\r\n                pool: options.pool,\r\n                schema: options.schema,\r\n                username: options.username,\r\n            };\r\n        }\r\n        var resolved = options;\r\n        resolved.hosts = resolved.hosts.map(function (host) {\r\n            return defaults({\r\n                host: host.host,\r\n                port: host.port,\r\n                protocol: host.protocol,\r\n                options: host.options,\r\n            }, defaultHost);\r\n        });\r\n        this.pool = new pool_1.Pool(resolved.pool);\r\n        this.options = defaults(resolved, defaultOptions);\r\n        resolved.hosts.forEach(function (host) {\r\n            _this.pool.addHost(host.protocol + \"://\" + host.host + \":\" + host.port, host.options);\r\n        });\r\n        this.options.schema.forEach(function (schema) {\r\n            var db = schema.database = schema.database || _this.options.database;\r\n            if (!db) {\r\n                throw new Error(\"Schema \" + schema.measurement + \" doesn't have a database specified,\" +\r\n                    'and no default database is provided!');\r\n            }\r\n            if (!_this.schema[db]) {\r\n                _this.schema[db] = Object.create(null);\r\n            }\r\n            _this.schema[db][schema.measurement] = new schema_1.Schema(schema);\r\n        });\r\n    }\r\n    /**\r\n     * Creates a new database with the provided name.\r\n     * @param {string} databaseName\r\n     * @return {Promise.<void>}\r\n     * @example\r\n     * influx.createDatabase('mydb')\r\n     */\r\n    InfluxDB.prototype.createDatabase = function (databaseName) {\r\n        return this.pool.json(this.getQueryOpts({\r\n            q: \"create database \" + grammar.escape.quoted(databaseName),\r\n        }, 'POST')).then(results_1.assertNoErrors);\r\n    };\r\n    /**\r\n     * Deletes a database with the provided name.\r\n     * @param {string} databaseName\r\n     * @return {Promise.<void>}\r\n     * @example\r\n     * influx.createDatabase('mydb')\r\n     */\r\n    InfluxDB.prototype.dropDatabase = function (databaseName) {\r\n        return this.pool.json(this.getQueryOpts({\r\n            q: \"drop database \" + grammar.escape.quoted(databaseName),\r\n        }, 'POST')).then(results_1.assertNoErrors);\r\n    };\r\n    /**\r\n     * Returns array of database names. Requires cluster admin privileges.\r\n     * @returns {Promise<String[]>} a list of database names\r\n     * @example\r\n     * influx.getMeasurements().then(names =>\r\n     *   console.log('My database names are: ' + names.join(', ')));\r\n     */\r\n    InfluxDB.prototype.getDatabaseNames = function () {\r\n        return this.pool.json(this.getQueryOpts({ q: 'show databases' }))\r\n            .then(function (res) { return results_1.parseSingle(res).map(function (r) { return r.name; }); });\r\n    };\r\n    /**\r\n     * Returns array of measurements.\r\n     * @returns {Promise<String[]>} a list of measurement names\r\n     * @param {String} [database] the database the measurement lives in, optional\r\n     *     if a default database is provided.\r\n     * @example\r\n     * influx.getMeasurements().then(names =>\r\n     *   console.log('My measurement names are: ' + names.join(', ')));\r\n     */\r\n    InfluxDB.prototype.getMeasurements = function (database) {\r\n        if (database === void 0) { database = this.defaultDB(); }\r\n        return this.pool.json(this.getQueryOpts({\r\n            db: database,\r\n            q: 'show measurements',\r\n        })).then(function (res) { return results_1.parseSingle(res).map(function (r) { return r.name; }); });\r\n    };\r\n    /**\r\n     * Returns a list of all series within the target measurement, or from the\r\n     * entire database if a measurement isn't provided.\r\n     * @param {Object} [options]\r\n     * @param {String} [options.measurement] if provided, we'll only get series\r\n     *     from within that measurement.\r\n     * @param {String} [options.database] the database the series lives in,\r\n     *     optional if a default database is provided.\r\n     * @returns {Promise<String[]>} a list of series names\r\n     * @example\r\n     * influx.getSeries().then(names => {\r\n     *   console.log('My series names in my_measurement are: ' + names.join(', '))\r\n     * })\r\n     *\r\n     * influx.getSeries({\r\n     *   measurement: 'my_measurement',\r\n     *   database: 'my_db'\r\n     * }).then(names => {\r\n     *   console.log('My series names in my_measurement are: ' + names.join(', '))\r\n     * })\r\n     */\r\n    InfluxDB.prototype.getSeries = function (options) {\r\n        if (options === void 0) { options = {}; }\r\n        var _a = options.database, database = _a === void 0 ? this.defaultDB() : _a, measurement = options.measurement;\r\n        var query = 'show series';\r\n        if (measurement) {\r\n            query += \" from \" + grammar.escape.quoted(measurement);\r\n        }\r\n        return this.pool.json(this.getQueryOpts({\r\n            db: database,\r\n            q: query,\r\n        })).then(function (res) { return results_1.parseSingle(res).map(function (r) { return r.key; }); });\r\n    };\r\n    /**\r\n     * Removes a measurement from the database.\r\n     * @param {String} measurement\r\n     * @param {String} [database] the database the measurement lives in, optional\r\n     *     if a default database is provided.\r\n     * @return {Promise.<void>}\r\n     * @example\r\n     * influx.dropMeasurement('my_measurement')\r\n     */\r\n    InfluxDB.prototype.dropMeasurement = function (measurement, database) {\r\n        if (database === void 0) { database = this.defaultDB(); }\r\n        return this.pool.json(this.getQueryOpts({\r\n            db: database,\r\n            q: \"drop measurement \" + grammar.escape.quoted(measurement),\r\n        }, 'POST')).then(results_1.assertNoErrors);\r\n    };\r\n    /**\r\n     * Removes a one or more series from InfluxDB.\r\n     *\r\n     * @returns {Promise<void>}\r\n     * @example\r\n     * // The following pairs of queries are equivalent: you can chose either to\r\n     * // use our builder or pass in string directly. The builder takes care\r\n     * // of escaping and most syntax handling for you.\r\n     *\r\n     * influx.dropSeries({ where: e => e.tag('cpu').equals.value('cpu8') })\r\n     * influx.dropSeries({ where: '\"cpu\" = \\'cpu8\\'' })\r\n     * // DROP SERIES WHERE \"cpu\" = 'cpu8'\r\n     *\r\n     * influx.dropSeries({ measurement: m => m.name('cpu').policy('autogen') })\r\n     * influx.dropSeries({ measurement: '\"cpu\".\"autogen\"' })\r\n     * // DROP SERIES FROM \"autogen\".\"cpu\"\r\n     *\r\n     * influx.dropSeries({\r\n     *   measurement: m => m.name('cpu').policy('autogen'),\r\n     *   where: e => e.tag('cpu').equals.value('cpu8'),\r\n     *   database: 'my_db'\r\n     * })\r\n     * // DROP SERIES FROM \"autogen\".\"cpu\" WHERE \"cpu\" = 'cpu8'\r\n     */\r\n    InfluxDB.prototype.dropSeries = function (options) {\r\n        var db = 'database' in options ? options.database : this.defaultDB();\r\n        var q = 'drop series';\r\n        if ('measurement' in options) {\r\n            q += ' from ' + b.parseMeasurement(options);\r\n        }\r\n        if ('where' in options) {\r\n            q += ' where ' + b.parseWhere(options);\r\n        }\r\n        return this.pool.json(this.getQueryOpts({ db: db, q: q }, 'POST')).then(results_1.assertNoErrors);\r\n    };\r\n    /**\r\n     * Returns a list of users on the Influx database.\r\n     * @return {Promise<Array<{ user: String, admin: Boolean }>>}\r\n     * @example\r\n     * influx.getUsers().then(users => {\r\n     *   users.forEach(user => {\r\n     *     if (user.admin) {\r\n     *       console.log(user.user, 'is an admin!')\r\n     *     } else {\r\n     *       console.log(user.user, 'is not an admin!')\r\n     *     }\r\n     *   })\r\n     * })\r\n     */\r\n    InfluxDB.prototype.getUsers = function () {\r\n        return this.pool.json(this.getQueryOpts({ q: 'show users' })).then(results_1.parseSingle);\r\n    };\r\n    /**\r\n     * Creates a new InfluxDB user.\r\n     * @param {String} username\r\n     * @param {String} password\r\n     * @param {Boolean} [admin=false] If true, the user will be given all\r\n     *     privileges on all databases.\r\n     * @return {Promise<void>}\r\n     * @example\r\n     * influx.createUser('connor', 'pa55w0rd', true) // make 'connor' an admin\r\n     *\r\n     * // make non-admins:\r\n     * influx.createUser('not_admin', 'pa55w0rd')\r\n     */\r\n    InfluxDB.prototype.createUser = function (username, password, admin) {\r\n        if (admin === void 0) { admin = false; }\r\n        return this.pool.json(this.getQueryOpts({\r\n            q: \"create user \" + grammar.escape.quoted(username) + \" with password \"\r\n                + grammar.escape.stringLit(password)\r\n                + (admin ? ' with all privileges' : ''),\r\n        }, 'POST')).then(results_1.assertNoErrors);\r\n    };\r\n    /**\r\n     * Sets a password for an Influx user.\r\n     * @param {String} username\r\n     * @param {String} password\r\n     * @return {Promise<void>}\r\n     * @example\r\n     * influx.setPassword('connor', 'pa55w0rd')\r\n     */\r\n    InfluxDB.prototype.setPassword = function (username, password) {\r\n        return this.pool.json(this.getQueryOpts({\r\n            q: \"set password for \" + grammar.escape.quoted(username) + \" = \"\r\n                + grammar.escape.stringLit(password),\r\n        }, 'POST')).then(results_1.assertNoErrors);\r\n    };\r\n    /**\r\n     * Grants a privilege to a specified user.\r\n     * @param {String} username\r\n     * @param {String} privilege Should be one of 'READ' or 'WRITE'\r\n     * @param {String} [database] If not provided, uses the default database.\r\n     * @return {Promise<void>}\r\n     * @example\r\n     * influx.grantPrivilege('connor', 'READ', 'my_db') // grants read access on my_db to connor\r\n     */\r\n    InfluxDB.prototype.grantPrivilege = function (username, privilege, database) {\r\n        if (database === void 0) { database = this.defaultDB(); }\r\n        return this.pool.json(this.getQueryOpts({\r\n            q: \"grant \" + privilege + \" on \" + grammar.escape.quoted(database) + \" \"\r\n                + (\"to \" + grammar.escape.quoted(username)),\r\n        }, 'POST')).then(results_1.assertNoErrors);\r\n    };\r\n    /**\r\n     * Removes a privilege from a specified user.\r\n     * @param {String} username\r\n     * @param {String} privilege Should be one of 'READ' or 'WRITE'\r\n     * @param {String} [database] If not provided, uses the default database.\r\n     * @return {Promise<void>}\r\n     * @example\r\n     * influx.revokePrivilege('connor', 'READ', 'my_db') // removes read access on my_db from connor\r\n     */\r\n    InfluxDB.prototype.revokePrivilege = function (username, privilege, database) {\r\n        if (database === void 0) { database = this.defaultDB(); }\r\n        return this.pool.json(this.getQueryOpts({\r\n            q: \"revoke \" + privilege + \" on \" + grammar.escape.quoted(database) + \" from \"\r\n                + grammar.escape.quoted(username),\r\n        }, 'POST')).then(results_1.assertNoErrors);\r\n    };\r\n    /**\r\n     * Grants admin privileges to a specified user.\r\n     * @param {String} username\r\n     * @return {Promise<void>}\r\n     * @example\r\n     * influx.grantAdminPrivilege('connor')\r\n     */\r\n    InfluxDB.prototype.grantAdminPrivilege = function (username) {\r\n        return this.pool.json(this.getQueryOpts({\r\n            q: \"grant all to \" + grammar.escape.quoted(username),\r\n        }, 'POST')).then(results_1.assertNoErrors);\r\n    };\r\n    /**\r\n     * Removes a admin privilege from a specified user.\r\n     * @param {String} username\r\n     * @return {Promise<void>}\r\n     * @example\r\n     * influx.revokeAdminPrivilege('connor')\r\n     */\r\n    InfluxDB.prototype.revokeAdminPrivilege = function (username) {\r\n        return this.pool.json(this.getQueryOpts({\r\n            q: \"revoke all from \" + grammar.escape.quoted(username),\r\n        }, 'POST')).then(results_1.assertNoErrors);\r\n    };\r\n    /**\r\n     * Removes a user from the database.\r\n     * @param {String} username\r\n     * @return {Promise<void>}\r\n     * @example\r\n     * influx.dropUser('connor')\r\n     */\r\n    InfluxDB.prototype.dropUser = function (username) {\r\n        return this.pool.json(this.getQueryOpts({\r\n            q: \"drop user \" + grammar.escape.quoted(username),\r\n        }, 'POST')).then(results_1.assertNoErrors);\r\n    };\r\n    /**\r\n     * Creates a continuous query in a database\r\n     * @param {String} name The query name, for later reference\r\n     * @param {String} query The body of the query to run\r\n     * @param {String} [database] If not provided, uses the default database.\r\n     * @return {Promise<void>}\r\n     * @example\r\n     * influx.createContinuousQuery('downsample_cpu_1h', `\r\n     *   SELECT MEAN(cpu) INTO \"7d\".\"perf\"\r\n     *   FROM \"1d\".\"perf\" GROUP BY time(1m)\r\n     * `)\r\n     */\r\n    InfluxDB.prototype.createContinuousQuery = function (name, query, database) {\r\n        if (database === void 0) { database = this.defaultDB(); }\r\n        return this.pool.json(this.getQueryOpts({\r\n            q: \"create continuous query \" + grammar.escape.quoted(name)\r\n                + (\" on \" + grammar.escape.quoted(database) + \" begin \" + query + \" end\"),\r\n        }, 'POST')).then(results_1.assertNoErrors);\r\n    };\r\n    /**\r\n     * Returns a list of continous queries in the database.\r\n     * @param {String} [database] If not provided, uses the default database.\r\n     * @return {Promise<void>}\r\n     * @example\r\n     * influx.showContinousQueries()\r\n     */\r\n    InfluxDB.prototype.showContinousQueries = function (database) {\r\n        if (database === void 0) { database = this.defaultDB(); }\r\n        return this.pool.json(this.getQueryOpts({\r\n            db: database,\r\n            q: 'show continuous queries',\r\n        })).then(results_1.parseSingle);\r\n    };\r\n    /**\r\n     * Creates a continuous query in a database\r\n     * @param {String} name The query name\r\n     * @param {String} [database] If not provided, uses the default database.\r\n     * @return {Promise<void>}\r\n     * @example\r\n     * influx.dropContinuousQuery('downsample_cpu_1h')\r\n     */\r\n    InfluxDB.prototype.dropContinuousQuery = function (name, database) {\r\n        if (database === void 0) { database = this.defaultDB(); }\r\n        return this.pool.json(this.getQueryOpts({\r\n            q: \"drop continuous query \" + grammar.escape.quoted(name)\r\n                + (\" on \" + grammar.escape.quoted(database)),\r\n        }, 'POST')).then(results_1.assertNoErrors);\r\n    };\r\n    /**\r\n     * Creates a new retention policy on a database. You can read more about\r\n     * [Downsampling and Retention](https://docs.influxdata.com/influxdb/v1.0/\r\n     * guides/downsampling_and_retention/) on the InfluxDB website.\r\n     *\r\n     * @param {String} name The retention policy name\r\n     * @param {Object} options\r\n     * @param {String} [options.database] Database to create the policy on,\r\n     *     uses the default database if not provided.\r\n     * @param {String} options.duration How long data in the retention policy\r\n     *     should be stored for, should be in a format like `7d`. See details\r\n     *     [here](https://docs.influxdata.com/influxdb/v1.0/query_language/spec/#durations)\r\n     * @param {Number} options.replication How many servers data in the series\r\n     *     should be replicated to.\r\n     * @param {Boolean} [options.isDefault] Whether the retention policy should\r\n     *     be the default policy on the database.\r\n     * @return {Promise<void>}\r\n     * @example\r\n     * influx.createRetentionPolicy('7d', {\r\n     *  duration: '7d',\r\n     *  replication: 1\r\n     * })\r\n     */\r\n    InfluxDB.prototype.createRetentionPolicy = function (name, options) {\r\n        var q = \"create retention policy \" + grammar.escape.quoted(name) + \" on \"\r\n            + grammar.escape.quoted(options.database || this.defaultDB())\r\n            + (\" duration \" + options.duration + \" replication \" + options.replication)\r\n            + (options.isDefault ? ' default' : '');\r\n        return this.pool.json(this.getQueryOpts({ q: q }, 'POST')).then(results_1.assertNoErrors);\r\n    };\r\n    /**\r\n     * Alters an existing retention policy on a database.\r\n     *\r\n     * @param {String} name The retention policy name\r\n     * @param {Object} options\r\n     * @param {String} [options.database] Database to create the policy on,\r\n     *     uses the default database if not provided.\r\n     * @param {String} options.duration How long data in the retention policy\r\n     *     should be stored for, should be in a format like `7d`. See details\r\n     *     [here](https://docs.influxdata.com/influxdb/v1.0/query_language/spec/#durations)\r\n     * @param {Number} options.replication How many servers data in the series\r\n     *     should be replicated to.\r\n     * @param {Boolean} [options.default] Whether the retention policy should\r\n     *     be the default policy on the database.\r\n     * @return {Promise<void>}\r\n     * @example\r\n     * influx.alterRetentionPolicy('7d', {\r\n     *  duration: '7d',\r\n     *  replication: 1,\r\n     *  default: true\r\n     * })\r\n     */\r\n    InfluxDB.prototype.alterRetentionPolicy = function (name, options) {\r\n        var q = \"alter retention policy \" + grammar.escape.quoted(name) + \" on \"\r\n            + grammar.escape.quoted(options.database || this.defaultDB())\r\n            + (\" duration \" + options.duration + \" replication \" + options.replication)\r\n            + (options.isDefault ? ' default' : '');\r\n        return this.pool.json(this.getQueryOpts({ q: q }, 'POST')).then(results_1.assertNoErrors);\r\n    };\r\n    /**\r\n     * Deletes a retention policy and associated data. Note that the data will\r\n     * not be immediately destroyed, and will hang around until Influx's\r\n     * bi-hourly cron.\r\n     *\r\n     * @param {String} name The retention policy name\r\n     * @param {String} [database] Database name that the policy lives in,\r\n     *     uses the default database if not provided.\r\n     * @return {Promise<void>}\r\n     * @example\r\n     * influx.dropRetentionPolicy('7d')\r\n     */\r\n    InfluxDB.prototype.dropRetentionPolicy = function (name, database) {\r\n        if (database === void 0) { database = this.defaultDB(); }\r\n        return this.pool.json(this.getQueryOpts({\r\n            q: \"drop retention policy \" + grammar.escape.quoted(name) + \" \"\r\n                + (\"on \" + grammar.escape.quoted(database)),\r\n        }, 'POST')).then(results_1.assertNoErrors);\r\n    };\r\n    /**\r\n     * Shows retention policies on the database\r\n     *\r\n     * @param {String} [database] The database to list policies on, uses the\r\n     *     default database if not provided.\r\n     * @return {Promise<Array<{\r\n     *     name: String,\r\n     *     duration: String,\r\n     *     shardGroupDuration: String,\r\n     *     replicaN: Number,\r\n     *     default: Boolean\r\n     * }>>}\r\n     * @example\r\n     * influx.showRetentionPolicies().then(policies => {\r\n     *   expect(policies.slice()).to.deep.equal([\r\n     *     {\r\n     *       name: 'autogen',\r\n     *       duration: '0s',\r\n     *       shardGroupDuration: '168h0m0s',\r\n     *       replicaN: 1,\r\n     *       default: true,\r\n     *     },\r\n     *     {\r\n     *       name: '7d',\r\n     *       duration: '168h0m0s',\r\n     *       shardGroupDuration: '24h0m0s',\r\n     *       replicaN: 1,\r\n     *       default: false,\r\n     *     },\r\n     *   ])\r\n     * })\r\n     */\r\n    InfluxDB.prototype.showRetentionPolicies = function (database) {\r\n        if (database === void 0) { database = this.defaultDB(); }\r\n        return this.pool.json(this.getQueryOpts({\r\n            q: \"show retention policies on \" + grammar.escape.quoted(database),\r\n        }, 'GET')).then(results_1.parseSingle);\r\n    };\r\n    /**\r\n     * writePoints sends a list of points together in a batch to InfluxDB. In\r\n     * each point you must specify the measurement name to write into as well\r\n     * as a list of tag and field values. Optionally, you can specify the\r\n     * time to tag that point at, defaulting to the current time.\r\n     *\r\n     * If you defined a schema for the measurement in the options you passed\r\n     * to `new Influx(options)`, we'll use that to make sure that types get\r\n     * cast correctly and that there are no extraneous fields or columns.\r\n     *\r\n     * For best performance, it's recommended that you batch your data into\r\n     * sets of a couple thousand records before writing it. In the future we'll\r\n     * have some utilities within node-influx to make this easier.\r\n     *\r\n     * ---\r\n     *\r\n     * A note when using manually-specified times and precisions: by default\r\n     * we write using the `ms` precision since that's what JavaScript gives us.\r\n     * You can adjust this. However, there is some special behaviour if you\r\n     * manually specify a timestamp in your points:\r\n     *  - if you specify the timestamp as a Date object, we'll convert it to\r\n     *    milliseconds and manipulate it as needed to get the right precision\r\n     *  - if provide a INanoDate as returned from {@link toNanoTime} or the\r\n     *    results from an Influx query, we'll be able to pull the precise\r\n     *    nanosecond timestamp and manipulate it to get the right precision\r\n     *  - if you provide a string or number as the timestamp, we'll pass it\r\n     *    straight into Influx.\r\n     *\r\n     * Please see the IPoint and IWriteOptions types for a\r\n     * full list of possible options.\r\n     *\r\n     * @param {IPoint[]} points\r\n     * @param {IWriteOptions} [options]\r\n     * @return {Promise<void>}\r\n     * @example\r\n     * // write a point into the default database with\r\n     * // the default retention policy.\r\n     * influx.writePoints([\r\n     *   {\r\n     *     measurement: 'perf',\r\n     *     tags: { host: 'box1.example.com' },\r\n     *     fields: { cpu: getCpuUsage(), mem: getMemUsage() },\r\n     *   }\r\n     * ])\r\n     *\r\n     * // you can manually specify the database,\r\n     * // retention policy, and time precision:\r\n     * influx.writePoints([\r\n     *   {\r\n     *     measurement: 'perf',\r\n     *     tags: { host: 'box1.example.com' },\r\n     *     fields: { cpu: getCpuUsage(), mem: getMemUsage() },\r\n     *     timestamp: getLastRecordedTime(),\r\n     *   }\r\n     * ], {\r\n     *   database: 'my_db',\r\n     *   retentionPolicy: '1d',\r\n     *   precision: 's'\r\n     * })\r\n     */\r\n    InfluxDB.prototype.writePoints = function (points, options) {\r\n        var _this = this;\r\n        if (options === void 0) { options = {}; }\r\n        var _a = options.database, database = _a === void 0 ? this.defaultDB() : _a, _b = options.precision, precision = _b === void 0 ? 'n' : _b, retentionPolicy = options.retentionPolicy;\r\n        var payload = '';\r\n        points.forEach(function (point) {\r\n            var _a = point.fields, fields = _a === void 0 ? {} : _a, _b = point.tags, tags = _b === void 0 ? {} : _b, measurement = point.measurement, timestamp = point.timestamp;\r\n            var schema = _this.schema[database] && _this.schema[database][measurement];\r\n            var fieldsPairs = schema ? schema.coerceFields(fields) : schema_1.coerceBadly(fields);\r\n            var tagsNames = schema ? schema.checkTags(tags) : Object.keys(tags);\r\n            payload += (payload.length > 0 ? '\\n' : '') + measurement;\r\n            for (var i = 0; i < tagsNames.length; i += 1) {\r\n                payload += ','\r\n                    + grammar.escape.tag(tagsNames[i])\r\n                    + '='\r\n                    + grammar.escape.tag(tags[tagsNames[i]]);\r\n            }\r\n            for (var i = 0; i < fieldsPairs.length; i += 1) {\r\n                payload += (i === 0 ? ' ' : ',')\r\n                    + grammar.escape.tag(fieldsPairs[i][0])\r\n                    + '='\r\n                    + fieldsPairs[i][1];\r\n            }\r\n            if (timestamp !== undefined) {\r\n                payload += ' ' + grammar.castTimestamp(timestamp, precision);\r\n            }\r\n        });\r\n        return this.pool.discard({\r\n            body: payload,\r\n            method: 'POST',\r\n            path: '/write',\r\n            query: Object.assign({\r\n                db: database,\r\n                p: this.options.password,\r\n                precision: precision,\r\n                rp: retentionPolicy,\r\n                u: this.options.username,\r\n            }),\r\n        });\r\n    };\r\n    /**\r\n     * writeMeasurement functions similarly to {@link InfluxDB#writePoints}, but\r\n     * it automatically fills in the `measurement` value for all points for you.\r\n     *\r\n     * @param {String} measurement\r\n     * @param {IPoint[]} points\r\n     * @param {IWriteOptions} [options]\r\n     * @return {Promise<void>}\r\n     * @example\r\n     * influx.writeMeasurement('perf', [\r\n     *   {\r\n     *     tags: { host: 'box1.example.com' },\r\n     *     fields: { cpu: getCpuUsage(), mem: getMemUsage() },\r\n     *   }\r\n     * ])\r\n     */\r\n    InfluxDB.prototype.writeMeasurement = function (measurement, points, options) {\r\n        if (options === void 0) { options = {}; }\r\n        points = points.map(function (p) { return Object.assign({ measurement: measurement }, p); });\r\n        return this.writePoints(points, options);\r\n    };\r\n    /**\r\n     * .query() runs a query (or list of queries), and returns the results in a\r\n     * friendly format, {@link IResults}. If you run multiple queries, an array of results\r\n     * will be returned, otherwise a single result (array of objects) will be returned.\r\n     *\r\n     * @param {String|String[]} query\r\n     * @param {IQueryOptions} [options]\r\n     * @return {Promise<IResults|Results[]>} result(s)\r\n     * @example\r\n     * influx.query('select * from perf').then(results => {\r\n     *   console.log(results)\r\n     * })\r\n     */\r\n    InfluxDB.prototype.query = function (query, options) {\r\n        if (options === void 0) { options = {}; }\r\n        if (Array.isArray(query)) {\r\n            query = query.join(';');\r\n        }\r\n        // If the consumer asked explicitly for nanosecond precision parsing,\r\n        // remove that to cause Influx to give us ISO dates that\r\n        // we can parse correctly.\r\n        if (options.precision === 'n') {\r\n            options = Object.assign({}, options); // avoid mutating\r\n            delete options.precision;\r\n        }\r\n        return this.queryRaw(query, options).then(function (res) { return results_1.parse(res, options.precision); });\r\n    };\r\n    /**\r\n     * queryRaw functions similarly to .query() but it does no fancy\r\n     * transformations on the returned data; it calls `JSON.parse` and returns\r\n     * those results verbatim.\r\n     *\r\n     * @param {String|String[]} query\r\n     * @param {IQueryOptions} [options]\r\n     * @return {Promise<*>}\r\n     * @example\r\n     * influx.queryRaw('select * from perf').then(rawData => {\r\n     *   console.log(rawData)\r\n     * })\r\n     */\r\n    InfluxDB.prototype.queryRaw = function (query, options) {\r\n        if (options === void 0) { options = {}; }\r\n        var _a = options.database, database = _a === void 0 ? this.defaultDB() : _a, retentionPolicy = options.retentionPolicy;\r\n        if (query instanceof Array) {\r\n            query = query.join(';');\r\n        }\r\n        return this.pool.json(this.getQueryOpts({\r\n            db: database,\r\n            epoch: options.precision,\r\n            q: query,\r\n            rp: retentionPolicy,\r\n        }));\r\n    };\r\n    /**\r\n     * Pings all available hosts, collecting online status and version info.\r\n     * @param  {Number}               timeout Given in milliseconds\r\n     * @return {Promise<IPingStats[]>}\r\n     * @example\r\n     * influx.ping(5000).then(hosts => {\r\n     *   hosts.forEach(host => {\r\n     *     if (host.online) {\r\n     *       console.log(`${host.url.host} responded in ${host.rtt}ms running ${host.version})`)\r\n     *     } else {\r\n     *       console.log(`${host.url.host} is offline :(`)\r\n     *     }\r\n     *   })\r\n     * })\r\n     */\r\n    InfluxDB.prototype.ping = function (timeout) {\r\n        return this.pool.ping(timeout);\r\n    };\r\n    /**\r\n     * Returns the default database that queries operates on. It throws if called\r\n     * when a default database isn't set.\r\n     * @private\r\n     */\r\n    InfluxDB.prototype.defaultDB = function () {\r\n        if (!this.options.database) {\r\n            throw new Error('Attempted to run an influx query without a default'\r\n                + ' database specified or an explicit database provided.');\r\n        }\r\n        return this.options.database;\r\n    };\r\n    /**\r\n     * Creates options to be passed into the pool to query databases.\r\n     * @private\r\n     */\r\n    InfluxDB.prototype.getQueryOpts = function (params, method) {\r\n        if (method === void 0) { method = 'GET'; }\r\n        return {\r\n            method: method,\r\n            path: '/query',\r\n            query: Object.assign({\r\n                p: this.options.password,\r\n                u: this.options.username,\r\n            }, params),\r\n        };\r\n    };\r\n    return InfluxDB;\r\n}());\r\nexports.InfluxDB = InfluxDB;\r\n","/home/travis/build/npmtest/node-npmtest-influx/node_modules/influx/lib/src/builder.js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar grammar_1 = require(\"./grammar\");\r\nfunction regexHasFlags(re) {\r\n    if (typeof re.flags !== 'undefined') {\r\n        return re.flags.length > 0;\r\n    }\r\n    return !(/\\/$/).test(re.toString());\r\n}\r\n/**\r\n * Expression is used to build filtering expressions, like those used in WHERE\r\n * clauses. It can be used for fluent and safe building of queries using\r\n * untrusted input.\r\n *\r\n * @example\r\n * e => e\r\n *   .field('host').equals.value('ares.peet.io')\r\n *   .or\r\n *   .field('host').matches(/example\\.com$/)\r\n *   .or\r\n *   .expr(e => e\r\n *     .field('country').equals.value('US')\r\n *     .and\r\n *     .field('state').equals.value('WA'));\r\n *\r\n * // Generates:\r\n * // \"host\" = 'ares.peet.io' OR \"host\" ~= /example\\.com$/ OR \\\r\n * //   (\"county\" = 'US' AND \"state\" = 'WA')\r\n */\r\nvar Expression = (function () {\r\n    function Expression() {\r\n        this.query = [];\r\n    }\r\n    /**\r\n     * Inserts a tag reference into the expression; the name will be\r\n     * automatically escaped.\r\n     * @param  {String} name\r\n     * @return {Expression}\r\n     */\r\n    Expression.prototype.tag = function (name) {\r\n        this.field(name);\r\n        return this;\r\n    };\r\n    /**\r\n     * Inserts a field reference into the expression; the name will be\r\n     * automatically escaped.\r\n     * @param  {String} name\r\n     * @return {Expression}\r\n     */\r\n    Expression.prototype.field = function (name) {\r\n        this.query.push(grammar_1.escape.quoted(name));\r\n        return this;\r\n    };\r\n    /**\r\n     * Inserts a subexpression; invokes the function with a new expression\r\n     * that can be chained on.\r\n     * @param  {function(e: Expression): Expression}  fn\r\n     * @return {Expression}\r\n     * @example\r\n     * e.field('a').equals.value('b')\r\n     *   .or.expr(e =>\r\n     *     e.field('b').equals.value('b')\r\n     *     .and.field('a').equals.value('c'))\r\n     *   .toString()\r\n     * // \"a\" = 'b' OR (\"b\" = 'b' AND \"a\" = 'c')\r\n     */\r\n    Expression.prototype.exp = function (fn) {\r\n        this.query.push('(' + fn(new Expression()).toString() + ')');\r\n        return this;\r\n    };\r\n    /**\r\n     * Value chains on a value to the expression.\r\n     *\r\n     *  - Numbers will be inserted verbatim\r\n     *  - Strings will be escaped and inserted\r\n     *  - Booleans will be inserted correctly\r\n     *  - Dates will be formatted and inserted correctly, including INanoDates.\r\n     *  - Regular expressions will be inserted correctly, however an error will\r\n     *    be thrown if they contain flags, as regex flags do not work in Influx\r\n     *  - Otherwise we'll try to call `.toString()` on the value, throwing\r\n     *    if we cannot do so.\r\n     *\r\n     * @param  {*}  value\r\n     * @return {Expression}\r\n     */\r\n    Expression.prototype.value = function (value) {\r\n        switch (typeof value) {\r\n            case 'number':\r\n                this.query.push(value);\r\n                return this;\r\n            case 'string':\r\n                this.query.push(grammar_1.escape.stringLit(value));\r\n                return this;\r\n            case 'boolean':\r\n                this.query.push(value ? 'TRUE' : 'FALSE');\r\n                return this;\r\n            default:\r\n                if (value instanceof Date) {\r\n                    this.query.push(grammar_1.formatDate(value));\r\n                    return this;\r\n                }\r\n                if (value instanceof RegExp) {\r\n                    if (regexHasFlags(value)) {\r\n                        throw new Error('Attempted to query using a regex with flags, ' +\r\n                            'but Influx doesn\\'t support flags in queries.');\r\n                    }\r\n                    this.query.push('/' + value.source + '/');\r\n                    return this;\r\n                }\r\n                if (value && typeof value.toString === 'function') {\r\n                    this.query.push(value.toString());\r\n                    return this;\r\n                }\r\n                throw new Error(\"node-influx doesn't know how to encode the provided value into a \" +\r\n                    'query. If you think this is a bug, open an issue here: https://git.io/influx-err');\r\n        }\r\n    };\r\n    Object.defineProperty(Expression.prototype, \"and\", {\r\n        /**\r\n         * Chains on an AND clause to the expression.\r\n         * @type {Expression}\r\n         */\r\n        get: function () {\r\n            this.query.push('AND');\r\n            return this;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Expression.prototype, \"or\", {\r\n        /**\r\n         * Chains on an OR clause to the expression.\r\n         * @type {Expression}\r\n         */\r\n        get: function () {\r\n            this.query.push('OR');\r\n            return this;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Expression.prototype, \"plus\", {\r\n        /**\r\n         * Chains on a `+` operator to the expression.\r\n         * @type {Expression}\r\n         */\r\n        get: function () {\r\n            this.query.push('+');\r\n            return this;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Expression.prototype, \"times\", {\r\n        /**\r\n         * Chains on a `*` operator to the expression.\r\n         * @type {Expression}\r\n         */\r\n        get: function () {\r\n            this.query.push('*');\r\n            return this;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Expression.prototype, \"minus\", {\r\n        /**\r\n         * Chains on a `-` operator to the expression.\r\n         * @type {Expression}\r\n         */\r\n        get: function () {\r\n            this.query.push('-');\r\n            return this;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Expression.prototype, \"div\", {\r\n        /**\r\n         * Chains on a `/` operator to the expression.\r\n         * @type {Expression}\r\n         */\r\n        get: function () {\r\n            this.query.push('/');\r\n            return this;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Expression.prototype, \"equals\", {\r\n        /**\r\n         * Chains on a `=` conditional to the expression.\r\n         * @type {Expression}\r\n         */\r\n        get: function () {\r\n            this.query.push('=');\r\n            return this;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Expression.prototype, \"matches\", {\r\n        /**\r\n         * Chains on a `=~` conditional to the expression to match regexes.\r\n         * @type {Expression}\r\n         */\r\n        get: function () {\r\n            this.query.push('=~');\r\n            return this;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Expression.prototype, \"doesntMatch\", {\r\n        /**\r\n         * Chains on a `!`` conditional to the expression to match regexes.\r\n         * @type {Expression}\r\n         */\r\n        get: function () {\r\n            this.query.push('!~');\r\n            return this;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Expression.prototype, \"notEqual\", {\r\n        /**\r\n         * Chains on a `!=` conditional to the expression.\r\n         * @type {Expression}\r\n         */\r\n        get: function () {\r\n            this.query.push('!=');\r\n            return this;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Expression.prototype, \"gt\", {\r\n        /**\r\n         * Chains on a `>` conditional to the expression.\r\n         * @type {Expression}\r\n         */\r\n        get: function () {\r\n            this.query.push('>');\r\n            return this;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Expression.prototype, \"gte\", {\r\n        /**\r\n         * Chains on a `>=` conditional to the expression.\r\n         * @type {Expression}\r\n         */\r\n        get: function () {\r\n            this.query.push('>=');\r\n            return this;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Expression.prototype, \"lt\", {\r\n        /**\r\n         * Chains on a `<` conditional to the expression.\r\n         * @type {Expression}\r\n         */\r\n        get: function () {\r\n            this.query.push('<');\r\n            return this;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Expression.prototype, \"lte\", {\r\n        /**\r\n         * Chains on a `<=` conditional to the expression.\r\n         * @type {Expression}\r\n         */\r\n        get: function () {\r\n            this.query.push('<=');\r\n            return this;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Converts the expression into its InfluxQL representation.\r\n     * @return {String}\r\n     */\r\n    Expression.prototype.toString = function () {\r\n        return this.query.join(' ');\r\n    };\r\n    return Expression;\r\n}());\r\nexports.Expression = Expression;\r\n/**\r\n * Measurement creates a reference to a particular measurement. You can\r\n * reference it solely by its name, but you can also specify the retention\r\n * policy and database it lives under.\r\n *\r\n * @example\r\n * m.name('my_measurement') // \"my_measurement\"\r\n * m.name('my_measurement').policy('one_day') // \"one_day\".\"my_measurement\"\r\n * m.name('my_measurement').policy('one_day').db('mydb') // \"mydb\".one_day\".\"my_measurement\"\r\n */\r\nvar Measurement = (function () {\r\n    function Measurement() {\r\n        this.parts = [null, null, null];\r\n    }\r\n    /**\r\n     * Sets the measurement name.\r\n     * @param  {String} name\r\n     * @return {Measurement}\r\n     */\r\n    Measurement.prototype.name = function (name) {\r\n        this.parts[2] = name;\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets the retention policy name.\r\n     * @param  {String} retentionPolicy\r\n     * @return {Measurement}\r\n     */\r\n    Measurement.prototype.policy = function (retentionPolicy) {\r\n        this.parts[1] = retentionPolicy;\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets the database name.\r\n     * @param  {String} db\r\n     * @return {Measurement}\r\n     */\r\n    Measurement.prototype.db = function (db) {\r\n        this.parts[0] = db;\r\n        return this;\r\n    };\r\n    /**\r\n     * Converts the measurement into its InfluxQL representation.\r\n     * @return {String}\r\n     * @throws {Error} if a measurement name is not provided\r\n     */\r\n    Measurement.prototype.toString = function () {\r\n        if (!this.parts[2]) {\r\n            throw new Error(\"You must specify a measurement name to query! Got `\" + this.parts[2] + \"`\");\r\n        }\r\n        return this.parts.filter(function (p) { return !!p; })\r\n            .map(function (p) { return grammar_1.escape.quoted(p); })\r\n            .join('.');\r\n    };\r\n    return Measurement;\r\n}());\r\nexports.Measurement = Measurement;\r\nfunction parseMeasurement(q) {\r\n    if (typeof q.measurement === 'function') {\r\n        return q.measurement(new Measurement()).toString();\r\n    }\r\n    return q.measurement;\r\n}\r\nexports.parseMeasurement = parseMeasurement;\r\nfunction parseWhere(q) {\r\n    if (typeof q.where === 'function') {\r\n        return q.where(new Expression()).toString();\r\n    }\r\n    return q.where;\r\n}\r\nexports.parseWhere = parseWhere;\r\n","/home/travis/build/npmtest/node-npmtest-influx/node_modules/influx/lib/src/grammar/index.js":"\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(require(\"./escape\"));\r\n__export(require(\"./ds\"));\r\n__export(require(\"./times\"));\r\n","/home/travis/build/npmtest/node-npmtest-influx/node_modules/influx/lib/src/grammar/escape.js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ds_1 = require(\"./ds\");\r\nvar reEscape = /[-|\\\\{()[\\]^$+*?.]/g;\r\n/**\r\n * The Escaper escapes the special characters in the provided list\r\n * with backslashes. Much of the code here is inspired by that in the\r\n * sqlstring packet found here: https://github.com/mysqljs/sqlstring\r\n *\r\n * Instances of the Escaper are derived from the documentation of escape\r\n * sequences found here: https://aka.ms/co1m4k\r\n *\r\n * sqlstring is made available under the following license:\r\n *\r\n *   Copyright (c) 2012 Felix Geisendörfer (felix@debuggable.com) and contributors\r\n *\r\n *   Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *   of this software and associated documentation files (the \"Software\"), to deal\r\n *   in the Software without restriction, including without limitation the rights\r\n *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *   copies of the Software, and to permit persons to whom the Software is\r\n *   furnished to do so, subject to the following conditions:\r\n *\r\n *   The above copyright notice and this permission notice shall be included in\r\n *   all copies or substantial portions of the Software.\r\n *\r\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *   THE SOFTWARE.\r\n *\r\n */\r\nvar Escaper = (function () {\r\n    function Escaper(chars, wrap, escaper) {\r\n        if (wrap === void 0) { wrap = ''; }\r\n        if (escaper === void 0) { escaper = '\\\\'; }\r\n        this.wrap = wrap;\r\n        this.escaper = escaper;\r\n        var patterns = chars.join('').replace(reEscape, '\\\\$&');\r\n        this.re = new RegExp('[' + patterns + '\\\\\\\\]', 'g');\r\n    }\r\n    /**\r\n     * Escape replaces occurrences of special characters within the target\r\n     * string with the necessary escape codes.\r\n     */\r\n    Escaper.prototype.escape = function (val) {\r\n        if (val instanceof ds_1.Raw) {\r\n            return val.getValue();\r\n        }\r\n        var chunkIndex = this.re.lastIndex = 0;\r\n        var escapedVal = '';\r\n        var match = this.re.exec(val);\r\n        while (match) {\r\n            escapedVal += val.slice(chunkIndex, match.index) + this.escaper + match[0];\r\n            chunkIndex = this.re.lastIndex;\r\n            match = this.re.exec(val);\r\n        }\r\n        if (chunkIndex === 0) {\r\n            return this.wrap + val + this.wrap;\r\n        }\r\n        if (chunkIndex < val.length) {\r\n            return this.wrap + escapedVal + val.slice(chunkIndex) + this.wrap;\r\n        }\r\n        return this.wrap + escapedVal + this.wrap;\r\n    };\r\n    return Escaper;\r\n}());\r\nvar bindEsc = function (e) { return e.escape.bind(e); };\r\n/**\r\n * tagEscaper escapes tag keys, tag values, and field keys.\r\n * @type {Object}\r\n * @property {function(s: string): string } quoted Escapes and wraps quoted\r\n *     values, such as database names.\r\n * @property {function(s: string): string } stringLit Escapes and\r\n *     wraps string literals.\r\n * @property {function(s: string): string } measurement Escapes measurement\r\n *     names on the line protocol.\r\n * @property {function(s: string): string } tag Escapes tag keys, take values,\r\n *     and field keys on the line protocol.\r\n *\r\n * @example\r\n * console.log(escape.quoted('my_\"db')); // => \"my_\\\"db\"\r\n * console.log(escape.stringLit('hello\\'world')); // => 'hello\\'world'\r\n *\r\n * console.log(escape.measurement('my measurement')); // => my\\ measurement\r\n * console.log(escape.tag('my tag=')); // => my\\ tag\\=\r\n */\r\nexports.escape = {\r\n    /**\r\n     * measurement escapes measurement names.\r\n     */\r\n    measurement: bindEsc(new Escaper([',', ' '])),\r\n    /**\r\n     * quoted escapes quoted values, such as database names.\r\n     */\r\n    quoted: bindEsc(new Escaper(['\"'], '\"')),\r\n    /**\r\n     * stringLitEscaper escapes single quotes in string literals.\r\n     */\r\n    stringLit: bindEsc(new Escaper(['\\''], '\\'')),\r\n    /**\r\n     * tagEscaper escapes tag keys, tag values, and field keys.\r\n     */\r\n    tag: bindEsc(new Escaper([',', '=', ' '])),\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-influx/node_modules/influx/lib/src/grammar/ds.js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * FieldType is an enumeration of InfluxDB field data types.\r\n * @typedef {Number} FieldType\r\n * @example\r\n * import { FieldType } from 'influx'; // or const FieldType = require('influx').FieldType\r\n *\r\n * const schema = {\r\n *   measurement: 'my_measurement',\r\n *   fields: {\r\n *     my_int: FieldType.INTEGER,\r\n *     my_float: FieldType.FLOAT,\r\n *     my_string: FieldType.STRING,\r\n *     my_boolean: FieldType.BOOLEAN,\r\n *   }\r\n * }\r\n */\r\nvar FieldType;\r\n(function (FieldType) {\r\n    FieldType[FieldType[\"FLOAT\"] = 0] = \"FLOAT\";\r\n    FieldType[FieldType[\"INTEGER\"] = 1] = \"INTEGER\";\r\n    FieldType[FieldType[\"STRING\"] = 2] = \"STRING\";\r\n    FieldType[FieldType[\"BOOLEAN\"] = 3] = \"BOOLEAN\";\r\n})(FieldType = exports.FieldType || (exports.FieldType = {}));\r\nfunction isNumeric(value) {\r\n    return !Number.isNaN(Number(value));\r\n}\r\nexports.isNumeric = isNumeric;\r\n/**\r\n * You can provide Raw values to Influx methods to prevent it from escaping\r\n * your provided string.\r\n * @class\r\n * @example\r\n * influx.createDatabase(new Influx.Raw('This won\\'t be escaped!'));\r\n */\r\nvar Raw = (function () {\r\n    /**\r\n     * Wraps a string so that it is not escaped in Influx queries.\r\n     * @param {String} value\r\n     * @example\r\n     * influx.createDatabase(new Influx.Raw('This won\\'t be escaped!'));\r\n     */\r\n    function Raw(value) {\r\n        this.value = value;\r\n    }\r\n    /**\r\n     * Returns the wrapped string.\r\n     * @return {String}\r\n     */\r\n    Raw.prototype.getValue = function () {\r\n        return this.value;\r\n    };\r\n    return Raw;\r\n}());\r\nexports.Raw = Raw;\r\n","/home/travis/build/npmtest/node-npmtest-influx/node_modules/influx/lib/src/grammar/times.js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ds_1 = require(\"./ds\");\r\n/**\r\n * Just a quick overview of what's going on in this file. It's a bit of a mess.\r\n * Influx uses three time formats:\r\n *  - ISO times with nanoseconds when querying where an epoch is not provided\r\n *  - Unix timestamps when querying with an epoch (specifying the precision\r\n *    in the given time unit)\r\n *  - Its own time format for time literals.\r\n *\r\n * To complicate matters, Influx operates on nanosecond precisions\r\n * by default, but we can't represent nanosecond timestamps in\r\n * JavaScript numbers as they're 64 bit uints.\r\n *\r\n * As a result we have several utilities to convert between these different\r\n * formats. When precision is required, we represent nanosecond timestamps\r\n * as strings and wrap default dates in the INanoDate interface which\r\n * lets the consumer read and write these more precise timestamps.\r\n *\r\n * Representing the timestamps as strings is definitely not a pure way to go\r\n * about it, but importing an arbitrary-precision integer library adds\r\n * bloat and is a massive hit to throughput. The operations we do do\r\n * are pretty trivial, so we stick with manipulating strings\r\n * and make sure to wash our hands when we're done.\r\n *\r\n * Vocabulary:\r\n *  Unix timestamp   = 'timestamp', abbreviated as 'time'\r\n *  ISO timestamp    = 'ISO time', abbreviated as 'ISO'\r\n *  Influx timestamp = 'Influx time', abbreviated as 'Influx'\r\n */\r\nfunction leftPad(str, length, pad) {\r\n    if (pad === void 0) { pad = '0'; }\r\n    if (typeof str === 'number') {\r\n        str = String(str);\r\n    }\r\n    while (str.length < length) {\r\n        str = pad + str;\r\n    }\r\n    return str;\r\n}\r\nfunction rightPad(str, length, pad) {\r\n    if (pad === void 0) { pad = '0'; }\r\n    if (typeof str === 'number') {\r\n        str = String(str);\r\n    }\r\n    while (str.length < length) {\r\n        str += pad;\r\n    }\r\n    return str;\r\n}\r\n/**\r\n * Precision is a map of available Influx time precisions.\r\n * @type {Object.<String, String>}\r\n * @example\r\n * console.log(Precision.Hours); // => 'h'\r\n * console.log(Precision.Minutes); // => 'm'\r\n * console.log(Precision.Seconds); // => 's'\r\n * console.log(Precision.Milliseconds); // => 'ms'\r\n * console.log(Precision.Microseconds); // => 'u'\r\n * console.log(Precision.Nanoseconds); // => 'ns'\r\n */\r\nexports.Precision = Object.freeze({\r\n    Hours: 'h',\r\n    Microseconds: 'u',\r\n    Milliseconds: 'ms',\r\n    Minutes: 'm',\r\n    Nanoseconds: 'n',\r\n    Seconds: 's',\r\n});\r\nvar MillisecondDateManipulator = (function () {\r\n    function MillisecondDateManipulator() {\r\n    }\r\n    MillisecondDateManipulator.prototype.format = function (date) {\r\n        return '\"' + leftPad(date.getUTCFullYear(), 2)\r\n            + '-' + leftPad(date.getUTCMonth() + 1, 2)\r\n            + '-' + leftPad(date.getUTCDate(), 2)\r\n            + ' ' + leftPad(date.getUTCHours(), 2)\r\n            + ':' + leftPad(date.getUTCMinutes(), 2)\r\n            + ':' + leftPad(date.getUTCSeconds(), 2)\r\n            + '.' + leftPad(date.getUTCMilliseconds(), 3) + '\"';\r\n    };\r\n    MillisecondDateManipulator.prototype.toTime = function (date, precision) {\r\n        var ms = date.getTime();\r\n        switch (precision) {\r\n            case 'n':\r\n                ms *= 1000;\r\n            case 'u':\r\n                ms *= 1000;\r\n            case 'ms':\r\n                return String(ms);\r\n            case 'h':\r\n                ms /= 60;\r\n            case 'm':\r\n                ms /= 60;\r\n            case 's':\r\n                ms /= 1000;\r\n                return String(Math.floor(ms));\r\n            default:\r\n                throw new Error(\"Unknown precision '\" + precision + \"'!\");\r\n        }\r\n    };\r\n    MillisecondDateManipulator.prototype.isoToDate = function (timestamp) {\r\n        return new Date(timestamp);\r\n    };\r\n    MillisecondDateManipulator.prototype.timetoDate = function (timestamp, precision) {\r\n        switch (precision) {\r\n            case 'n':\r\n                timestamp /= 1000;\r\n            case 'u':\r\n                timestamp /= 1000;\r\n            case 'ms':\r\n                return new Date(timestamp);\r\n            case 'h':\r\n                timestamp *= 60;\r\n            case 'm':\r\n                timestamp *= 60;\r\n            case 's':\r\n                timestamp *= 1000;\r\n                return new Date(timestamp);\r\n            default:\r\n                throw new Error(\"Unknown precision '\" + precision + \"'!\");\r\n        }\r\n    };\r\n    return MillisecondDateManipulator;\r\n}());\r\nvar nsPer = {\r\n    ms: Math.pow(10, 6),\r\n    s: Math.pow(10, 9),\r\n};\r\nfunction nanoIsoToTime(iso) {\r\n    var _a = iso.split('.'), secondsStr = _a[0], decimalStr = _a[1];\r\n    if (decimalStr === undefined) {\r\n        decimalStr = '000000000';\r\n    }\r\n    else {\r\n        decimalStr = rightPad(decimalStr.slice(0, -1), 9);\r\n        secondsStr += 'Z';\r\n    }\r\n    var seconds = Math.floor(new Date(secondsStr).getTime() / 1000);\r\n    return \"\" + seconds + decimalStr;\r\n}\r\nvar nanoDateMethods = {\r\n    getNanoTimeFromISO: function () {\r\n        if (!this._cachedNanoISO) {\r\n            this._cachedNanoTime = nanoIsoToTime(this._nanoISO);\r\n        }\r\n        return this._cachedNanoTime;\r\n    },\r\n    toNanoISOStringFromISO: function () {\r\n        if (!this._cachedNanoISO) {\r\n            this._cachedNanoTime = nanoIsoToTime(this._nanoISO);\r\n        }\r\n        var base = this.toISOString().slice(0, -4); // slice of `123Z` milliseconds\r\n        return \"\" + base + this._cachedNanoTime.slice(-9) + \"Z\";\r\n    },\r\n    getNanoTimeFromStamp: function () {\r\n        return this._nanoTime;\r\n    },\r\n    toNanoISOStringFromStamp: function () {\r\n        var base = this.toISOString().slice(0, -4); // slice of `123Z` milliseconds\r\n        return \"\" + base + this._nanoTime.slice(-9) + \"Z\";\r\n    },\r\n};\r\n/**\r\n * Covers a nanoseconds unix timestamp to a INanoDate for node-influx. The\r\n * timestamp is provided as a string to prevent precision loss.\r\n *\r\n * Please see [A Moment for Times](https://node-influx.github.io/manual/\r\n * usage.html#a-moment-for-times) for a more complete and eloquent explanation\r\n * of time handling in this module.\r\n *\r\n * @param {String} timestamp\r\n * @returns {INanoDate}\r\n * @example\r\n * const date = toNanoDate('1475985480231035600')\r\n *\r\n * // You can use the returned Date as a normal date:\r\n * expect(date.getTime()).to.equal(1475985480231);\r\n *\r\n * // We decorate it with two additional methods to read\r\n * // nanosecond-precision results:\r\n * expect(date.getNanoTime()).to.equal('1475985480231035600');\r\n * expect(date.toNanoISOString()).to.equal('2016-10-09T03:58:00.231035600Z');\r\n */\r\nfunction toNanoDate(timestamp) {\r\n    var date = new Date(Math.floor(Number(timestamp) / nsPer.ms));\r\n    date._nanoTime = timestamp;\r\n    date.getNanoTime = nanoDateMethods.getNanoTimeFromStamp;\r\n    date.toNanoISOString = nanoDateMethods.toNanoISOStringFromStamp;\r\n    return date;\r\n}\r\nexports.toNanoDate = toNanoDate;\r\nfunction asNanoDate(date) {\r\n    var d = date;\r\n    if (d.getNanoTime) {\r\n        return d;\r\n    }\r\n    return undefined;\r\n}\r\nvar NanosecondsDateManipulator = (function () {\r\n    function NanosecondsDateManipulator() {\r\n    }\r\n    NanosecondsDateManipulator.prototype.format = function (date) {\r\n        return '\"' + leftPad(date.getUTCFullYear(), 2)\r\n            + '-' + leftPad(date.getUTCMonth() + 1, 2)\r\n            + '-' + leftPad(date.getUTCDate(), 2)\r\n            + ' ' + leftPad(date.getUTCHours(), 2)\r\n            + ':' + leftPad(date.getUTCMinutes(), 2)\r\n            + ':' + leftPad(date.getUTCSeconds(), 2)\r\n            + '.' + date.getNanoTime().slice(-9) + '\"';\r\n    };\r\n    NanosecondsDateManipulator.prototype.toTime = function (date, precision) {\r\n        var ms = date.getTime();\r\n        switch (precision) {\r\n            case 'u':\r\n                return date.getNanoTime().slice(0, -3);\r\n            case 'n':\r\n                return date.getNanoTime();\r\n            case 'h':\r\n                ms /= 60;\r\n            case 'm':\r\n                ms /= 60;\r\n            case 's':\r\n                ms /= 1000;\r\n            case 'ms':\r\n                return String(Math.floor(ms));\r\n            default:\r\n                throw new Error(\"Unknown precision '\" + precision + \"'!\");\r\n        }\r\n    };\r\n    NanosecondsDateManipulator.prototype.isoToDate = function (timestamp) {\r\n        var date = new Date(timestamp);\r\n        date._nanoISO = timestamp;\r\n        date.getNanoTime = nanoDateMethods.getNanoTimeFromISO;\r\n        date.toNanoISOString = nanoDateMethods.toNanoISOStringFromISO;\r\n        return date;\r\n    };\r\n    NanosecondsDateManipulator.prototype.timetoDate = function (timestamp, precision) {\r\n        switch (precision) {\r\n            case 'h':\r\n                timestamp *= 60;\r\n            case 'm':\r\n                timestamp *= 60;\r\n            case 's':\r\n                timestamp *= 1000;\r\n            case 'ms':\r\n                timestamp *= 1000;\r\n            case 'u':\r\n                timestamp *= 1000;\r\n            case 'n':\r\n                var date = new Date(timestamp / nsPer.ms);\r\n                date._nanoTime = String(timestamp);\r\n                date.getNanoTime = nanoDateMethods.getNanoTimeFromStamp;\r\n                date.toNanoISOString = nanoDateMethods.toNanoISOStringFromStamp;\r\n                return date;\r\n            default:\r\n                throw new Error(\"Unknown precision '\" + precision + \"'!\");\r\n        }\r\n    };\r\n    return NanosecondsDateManipulator;\r\n}());\r\nvar milliManipulator = new MillisecondDateManipulator();\r\nvar nanoManipulator = new NanosecondsDateManipulator();\r\n/**\r\n * formatDate converts the Date instance to Influx's date query format.\r\n * @private\r\n */\r\nfunction formatDate(date) {\r\n    var nano = asNanoDate(date);\r\n    if (nano) {\r\n        return nanoManipulator.format(nano);\r\n    }\r\n    else {\r\n        return milliManipulator.format(date);\r\n    }\r\n}\r\nexports.formatDate = formatDate;\r\n/**\r\n * Converts a Date instance to a timestamp with the specified time precision.\r\n * @private\r\n */\r\nfunction dateToTime(date, precision) {\r\n    var nano = asNanoDate(date);\r\n    if (nano) {\r\n        return nanoManipulator.toTime(nano, precision);\r\n    }\r\n    else {\r\n        return milliManipulator.toTime(date, precision);\r\n    }\r\n}\r\nexports.dateToTime = dateToTime;\r\n/**\r\n * Converts an ISO-formatted data or unix timestamp to a Date instance. If\r\n * the precision is finer than 'ms' the returned value will be a INanoDate.\r\n * @private\r\n */\r\nfunction isoOrTimeToDate(stamp, precision) {\r\n    if (precision === void 0) { precision = 'n'; }\r\n    if (typeof stamp === 'string') {\r\n        return nanoManipulator.isoToDate(stamp);\r\n    }\r\n    else {\r\n        return nanoManipulator.timetoDate(stamp, precision);\r\n    }\r\n}\r\nexports.isoOrTimeToDate = isoOrTimeToDate;\r\n/**\r\n * Converts a timestamp to a string with the correct precision. Assumes\r\n * that raw number and string instances are already in the correct precision.\r\n * @private\r\n */\r\nfunction castTimestamp(timestamp, precision) {\r\n    if (typeof timestamp === 'string') {\r\n        if (!ds_1.isNumeric(timestamp)) {\r\n            throw new Error(\"Expected numeric value for, timestamp, but got '\" + timestamp + \"'!\");\r\n        }\r\n        return timestamp;\r\n    }\r\n    if (typeof timestamp === 'number') {\r\n        return String(timestamp);\r\n    }\r\n    return dateToTime(timestamp, precision);\r\n}\r\nexports.castTimestamp = castTimestamp;\r\n","/home/travis/build/npmtest/node-npmtest-influx/node_modules/influx/lib/src/pool.js":"\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar exponential_1 = require(\"./backoff/exponential\");\r\nvar host_1 = require(\"./host\");\r\nvar http = require(\"http\");\r\nvar https = require(\"https\");\r\nvar querystring = require(\"querystring\");\r\n/**\r\n * Status codes that will cause a host to be marked as 'failed' if we get\r\n * them from a request to Influx.\r\n * @type {Array}\r\n */\r\nvar resubmitErrorCodes = [\r\n    'ETIMEDOUT',\r\n    'ESOCKETTIMEDOUT',\r\n    'ECONNRESET',\r\n    'ECONNREFUSED',\r\n    'EHOSTUNREACH',\r\n];\r\n/**\r\n * An ServiceNotAvailableError is returned as an error from requests that\r\n * result in a > 500 error code.\r\n */\r\nvar ServiceNotAvailableError = (function (_super) {\r\n    __extends(ServiceNotAvailableError, _super);\r\n    function ServiceNotAvailableError(message) {\r\n        var _this = _super.call(this) || this;\r\n        _this.message = message;\r\n        Object.setPrototypeOf(_this, ServiceNotAvailableError.prototype);\r\n        return _this;\r\n    }\r\n    return ServiceNotAvailableError;\r\n}(Error));\r\nexports.ServiceNotAvailableError = ServiceNotAvailableError;\r\n/**\r\n * An RequestError is returned as an error from requests that\r\n * result in a 300 <= error code <= 500.\r\n */\r\nvar RequestError = (function (_super) {\r\n    __extends(RequestError, _super);\r\n    function RequestError(req, res, body) {\r\n        var _this = _super.call(this) || this;\r\n        _this.req = req;\r\n        _this.res = res;\r\n        _this.message = \"A \" + res.statusCode + \" \" + res.statusMessage + \" error occurred: \" + body;\r\n        Object.setPrototypeOf(_this, RequestError.prototype);\r\n        return _this;\r\n    }\r\n    RequestError.Create = function (req, res, callback) {\r\n        var body = '';\r\n        res.on('data', function (str) { return body = body + str.toString(); });\r\n        res.on('end', function () { return callback(new RequestError(req, res, body)); });\r\n    };\r\n    return RequestError;\r\n}(Error));\r\nexports.RequestError = RequestError;\r\n/**\r\n * Creates a function generation that returns a wrapper which only allows\r\n * through the first call of any function that it generated.\r\n */\r\nfunction doOnce() {\r\n    var handled = false;\r\n    return function (fn) {\r\n        return function (arg) {\r\n            if (handled) {\r\n                return;\r\n            }\r\n            handled = true;\r\n            fn(arg);\r\n        };\r\n    };\r\n}\r\nfunction setToArray(itemSet) {\r\n    var output = [];\r\n    itemSet.forEach(function (value) {\r\n        output.push(value);\r\n    });\r\n    return output;\r\n}\r\nvar request = function (options, callback) {\r\n    if (options.protocol === 'https:') {\r\n        return https.request(options, callback);\r\n    }\r\n    else {\r\n        return http.request(options, callback);\r\n    }\r\n};\r\n/**\r\n *\r\n * The Pool maintains a list available Influx hosts and dispatches requests\r\n * to them. If there are errors connecting to hosts, it will disable that\r\n * host for a period of time.\r\n */\r\nvar Pool = (function () {\r\n    /**\r\n     * Creates a new Pool instance.\r\n     * @param {IPoolOptions} options\r\n     */\r\n    function Pool(options) {\r\n        this.options = Object.assign({\r\n            backoff: new exponential_1.ExponentialBackoff({\r\n                initial: 300,\r\n                max: 10 * 1000,\r\n                random: 1,\r\n            }),\r\n            maxRetries: 2,\r\n            requestTimeout: 30 * 1000,\r\n        }, options);\r\n        this.index = 0;\r\n        this.hostsAvailable = new Set();\r\n        this.hostsDisabled = new Set();\r\n        this.timeout = this.options.requestTimeout;\r\n    }\r\n    /**\r\n     * Returns a list of currently active hosts.\r\n     * @return {Host[]}\r\n     */\r\n    Pool.prototype.getHostsAvailable = function () {\r\n        return setToArray(this.hostsAvailable);\r\n    };\r\n    /**\r\n     * Returns a list of hosts that are currently disabled due to network\r\n     * errors.\r\n     * @return {Host[]}\r\n     */\r\n    Pool.prototype.getHostsDisabled = function () {\r\n        return setToArray(this.hostsDisabled);\r\n    };\r\n    /**\r\n     * Inserts a new host to the pool.\r\n     */\r\n    Pool.prototype.addHost = function (url, options) {\r\n        if (options === void 0) { options = {}; }\r\n        var host = new host_1.Host(url, this.options.backoff.reset(), options);\r\n        this.hostsAvailable.add(host);\r\n        return host;\r\n    };\r\n    /**\r\n     * Returns true if there's any host available to by queried.\r\n     * @return {Boolean}\r\n     */\r\n    Pool.prototype.hostIsAvailable = function () {\r\n        return this.hostsAvailable.size > 0;\r\n    };\r\n    /**\r\n     * Makes a request and calls back with the response, parsed as JSON.\r\n     * An error is returned on a non-2xx status code or on a parsing exception.\r\n     */\r\n    Pool.prototype.json = function (options) {\r\n        return this.text(options).then(function (res) { return JSON.parse(res); });\r\n    };\r\n    /**\r\n     * Makes a request and resolves with the plain text response,\r\n     * if possible. An error is raised on a non-2xx status code.\r\n     */\r\n    Pool.prototype.text = function (options) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.stream(options, function (err, res) {\r\n                if (err) {\r\n                    return reject(err);\r\n                }\r\n                var output = '';\r\n                res.on('data', function (str) { return output = output + str.toString(); });\r\n                res.on('end', function () { return resolve(output); });\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Makes a request and discards any response body it receives.\r\n     * An error is returned on a non-2xx status code.\r\n     */\r\n    Pool.prototype.discard = function (options) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.stream(options, function (err, res) {\r\n                if (err) {\r\n                    return reject(err);\r\n                }\r\n                res.on('data', function () { });\r\n                res.on('end', function () { return resolve(); });\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Ping sends out a request to all available Influx servers, reporting on\r\n     * their response time and version number.\r\n     */\r\n    Pool.prototype.ping = function (timeout, path) {\r\n        if (path === void 0) { path = '/ping'; }\r\n        var todo = [];\r\n        setToArray(this.hostsAvailable)\r\n            .concat(setToArray(this.hostsDisabled))\r\n            .forEach(function (host) {\r\n            var start = Date.now();\r\n            var url = host.url;\r\n            var once = doOnce();\r\n            return todo.push(new Promise(function (resolve) {\r\n                var req = request(Object.assign({\r\n                    hostname: url.hostname,\r\n                    method: 'GET',\r\n                    path: path,\r\n                    port: Number(url.port),\r\n                    protocol: url.protocol,\r\n                    timeout: timeout,\r\n                }, host.options), once(function (res) {\r\n                    resolve({\r\n                        url: url,\r\n                        res: res,\r\n                        online: res.statusCode < 300,\r\n                        rtt: Date.now() - start,\r\n                        version: res.headers['x-influxdb-version'],\r\n                    });\r\n                }));\r\n                var fail = once(function () {\r\n                    resolve({\r\n                        online: false,\r\n                        res: null,\r\n                        rtt: Infinity,\r\n                        url: url,\r\n                        version: null,\r\n                    });\r\n                });\r\n                // Support older Nodes and polyfills which don't allow .timeout() in\r\n                // the request options, wrapped in a conditional for even worse\r\n                // polyfills. See: https://github.com/node-influx/node-influx/issues/221\r\n                if (typeof req.setTimeout === 'function') {\r\n                    req.setTimeout(timeout, fail); // tslint:disable-line\r\n                }\r\n                req.on('timeout', fail);\r\n                req.on('error', fail);\r\n                req.end();\r\n            }));\r\n        });\r\n        return Promise.all(todo);\r\n    };\r\n    /**\r\n     * Makes a request and calls back with the IncomingMessage stream,\r\n     * if possible. An error is returned on a non-2xx status code.\r\n     */\r\n    Pool.prototype.stream = function (options, callback) {\r\n        var _this = this;\r\n        if (!this.hostIsAvailable()) {\r\n            return callback(new ServiceNotAvailableError('No host available'), null);\r\n        }\r\n        var path = options.path;\r\n        if (options.query) {\r\n            path += '?' + querystring.stringify(options.query);\r\n        }\r\n        var once = doOnce();\r\n        var host = this.getHost();\r\n        var req = request(Object.assign({\r\n            headers: { 'content-length': options.body ? new Buffer(options.body).length : 0 },\r\n            hostname: host.url.hostname,\r\n            method: options.method,\r\n            path: path,\r\n            port: Number(host.url.port),\r\n            protocol: host.url.protocol,\r\n            timeout: this.timeout,\r\n        }, host.options), once(function (res) {\r\n            if (res.statusCode >= 500) {\r\n                return _this.handleRequestError(new ServiceNotAvailableError(res.statusMessage), host, options, callback);\r\n            }\r\n            if (res.statusCode >= 300) {\r\n                return RequestError.Create(req, res, function (err) { return callback(err, res); });\r\n            }\r\n            host.success();\r\n            return callback(undefined, res);\r\n        }));\r\n        // Handle network or HTTP parsing errors:\r\n        req.on('error', once(function (err) {\r\n            _this.handleRequestError(err, host, options, callback);\r\n        }));\r\n        // Handle timeouts:\r\n        req.on('timeout', once(function () {\r\n            _this.handleRequestError(new ServiceNotAvailableError('Request timed out'), host, options, callback);\r\n        }));\r\n        // Support older Nodes and polyfills which don't allow .timeout() in the\r\n        // request options, wrapped in a conditional for even worse polyfills. See:\r\n        // https://github.com/node-influx/node-influx/issues/221\r\n        if (typeof req.setTimeout === 'function') {\r\n            req.setTimeout(this.timeout); // tslint:disable-line\r\n        }\r\n        // Write out the body:\r\n        if (options.body) {\r\n            req.write(options.body);\r\n        }\r\n        req.end();\r\n    };\r\n    /**\r\n     * Returns the next available host for querying.\r\n     * @return {Host}\r\n     */\r\n    Pool.prototype.getHost = function () {\r\n        var available = setToArray(this.hostsAvailable);\r\n        var host = available[this.index];\r\n        this.index = (this.index + 1) % available.length;\r\n        return host;\r\n    };\r\n    /**\r\n     * Re-enables the provided host, returning it to the pool to query.\r\n     * @param  {Host} host\r\n     */\r\n    Pool.prototype.enableHost = function (host) {\r\n        this.hostsDisabled.delete(host);\r\n        this.hostsAvailable.add(host);\r\n    };\r\n    /**\r\n     * Disables the provided host, removing it from the query pool. It will be\r\n     * re-enabled after a backoff interval\r\n     */\r\n    Pool.prototype.disableHost = function (host) {\r\n        var _this = this;\r\n        this.hostsAvailable.delete(host);\r\n        this.hostsDisabled.add(host);\r\n        this.index %= Math.max(1, this.hostsAvailable.size);\r\n        setTimeout(function () { return _this.enableHost(host); }, host.fail());\r\n    };\r\n    Pool.prototype.handleRequestError = function (err, host, options, callback) {\r\n        if (!(err instanceof ServiceNotAvailableError) &&\r\n            resubmitErrorCodes.indexOf(err.code) === -1) {\r\n            return callback(err, null);\r\n        }\r\n        this.disableHost(host);\r\n        var retries = options.retries || 0;\r\n        if (retries < this.options.maxRetries && this.hostIsAvailable()) {\r\n            options.retries = retries + 1;\r\n            return this.stream(options, callback);\r\n        }\r\n        callback(err, null);\r\n    };\r\n    return Pool;\r\n}());\r\nexports.Pool = Pool;\r\n","/home/travis/build/npmtest/node-npmtest-influx/node_modules/influx/lib/src/backoff/exponential.js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @class\r\n * @implements {IBackoffStrategy}\r\n */\r\nvar ExponentialBackoff = (function () {\r\n    /**\r\n     * Creates a new exponential backoff strategy.\r\n     * @see https://en.wikipedia.org/wiki/Exponential_backoff\r\n     * @param {IExponentialOptions} options\r\n     */\r\n    function ExponentialBackoff(options) {\r\n        this.options = options;\r\n        this.counter = 0;\r\n    }\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ExponentialBackoff.prototype.getDelay = function () {\r\n        var count = this.counter - Math.round(Math.random() * this.options.random); // tslint:disable-line\r\n        return Math.min(this.options.max, this.options.initial * Math.pow(2, Math.max(count, 0)));\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ExponentialBackoff.prototype.next = function () {\r\n        var next = new ExponentialBackoff(this.options);\r\n        next.counter = this.counter + 1;\r\n        return next;\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ExponentialBackoff.prototype.reset = function () {\r\n        return new ExponentialBackoff(this.options);\r\n    };\r\n    return ExponentialBackoff;\r\n}());\r\nexports.ExponentialBackoff = ExponentialBackoff;\r\n","/home/travis/build/npmtest/node-npmtest-influx/node_modules/influx/lib/src/host.js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar urlModule = require(\"url\");\r\nvar Host = (function () {\r\n    /**\r\n     * Creates a new Host instance.\r\n     * @param {String} url\r\n     * @param {IBackoffStrategy} backoff\r\n     */\r\n    function Host(url, backoff, options) {\r\n        this.backoff = backoff;\r\n        this.options = options;\r\n        this.url = urlModule.parse(url);\r\n    }\r\n    /**\r\n     * Marks a failure on the host and returns the length of time it\r\n     * should be removed from the pool\r\n     * @return {Number} removal time in milliseconds\r\n     */\r\n    Host.prototype.fail = function () {\r\n        var value = this.backoff.getDelay();\r\n        this.backoff = this.backoff.next();\r\n        return value;\r\n    };\r\n    /**\r\n     * Should be called when a successful operation is run against the host.\r\n     * It resets the host's backoff strategy.\r\n     */\r\n    Host.prototype.success = function () {\r\n        this.backoff = this.backoff.reset();\r\n    };\r\n    return Host;\r\n}());\r\nexports.Host = Host;\r\n","/home/travis/build/npmtest/node-npmtest-influx/node_modules/influx/lib/src/results.js":"\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar grammar_1 = require(\"./grammar\");\r\n/**\r\n * A ResultError is thrown when a query generates errorful results from Influx.\r\n */\r\nvar ResultError = (function (_super) {\r\n    __extends(ResultError, _super);\r\n    function ResultError(message) {\r\n        var _this = _super.call(this) || this;\r\n        _this.message = \"Error from InfluxDB: \" + message;\r\n        return _this;\r\n    }\r\n    return ResultError;\r\n}(Error));\r\nexports.ResultError = ResultError;\r\nfunction groupMethod(matcher) {\r\n    // We do a tiny bit of 'custom' deep equality checking here, taking\r\n    // advantage of the fact that the tag keys are consistent across all\r\n    // series results. This lets us match groupings much more efficiently,\r\n    // ~6000x faster than the fastest vanilla equality checker (lodash)\r\n    // when operating on large (~100,000 grouping) sets.\r\n    var srcKeys = this.groupsTagsKeys;\r\n    var dstKeys = Object.keys(matcher);\r\n    if (srcKeys.length === 0 || srcKeys.length !== dstKeys.length) {\r\n        return [];\r\n    }\r\n    L: for (var i = 0; i < this.groupRows.length; i += 1) {\r\n        for (var k = 0; k < srcKeys.length; k += 1) {\r\n            if (this.groupRows[i].tags[srcKeys[k]] !== matcher[srcKeys[k]]) {\r\n                continue L;\r\n            }\r\n        }\r\n        return this.groupRows[i].rows;\r\n    }\r\n    return [];\r\n}\r\nfunction groupsMethod() {\r\n    return this.groupRows;\r\n}\r\n/**\r\n * Inner parsing function which unpacks the series into a table and attaches\r\n * methods to the array. This is quite optimized and a bit of a mess to read,\r\n * but it's all fairly easy procedural logic.\r\n *\r\n * We do this instead of subclassing Array since subclassing has some\r\n * undesirable side-effects. For example, calling .slice() on the array\r\n * makes it impossible to preserve groups as would be necessary if it's\r\n * subclassed.\r\n */\r\nfunction parseInner(series, precision) {\r\n    if (series === void 0) { series = []; }\r\n    var results = [];\r\n    var tags = results.groupsTagsKeys\r\n        = series.length && series[0].tags ? Object.keys(series[0].tags) : [];\r\n    var nextGroup = [];\r\n    results.groupRows = new Array(series.length); // tslint:disable-line\r\n    var lastEnd = 0;\r\n    for (var i = 0; i < series.length; i += 1, lastEnd = results.length) {\r\n        var _a = series[i], _b = _a.columns, columns = _b === void 0 ? [] : _b, _c = _a.values, values = _c === void 0 ? [] : _c;\r\n        for (var k = 0; k < values.length; k += 1) {\r\n            var obj = {};\r\n            for (var j = 0; j < columns.length; j += 1) {\r\n                if (columns[j] === 'time') {\r\n                    obj.time = grammar_1.isoOrTimeToDate(values[k][j], precision);\r\n                }\r\n                else {\r\n                    obj[columns[j]] = values[k][j];\r\n                }\r\n            }\r\n            for (var j = 0; j < tags.length; j += 1) {\r\n                obj[tags[j]] = series[i].tags[tags[j]];\r\n            }\r\n            results.push(obj);\r\n            nextGroup.push(obj);\r\n        }\r\n        results.groupRows[i] = {\r\n            name: series[i].name,\r\n            rows: nextGroup,\r\n            tags: series[i].tags || {},\r\n        };\r\n        nextGroup = [];\r\n    }\r\n    results.group = groupMethod;\r\n    results.groups = groupsMethod;\r\n    return results;\r\n}\r\n/**\r\n * Checks if there are any errors in the IResponse and, if so, it throws them.\r\n * @private\r\n * @throws {ResultError}\r\n */\r\nfunction assertNoErrors(res) {\r\n    for (var i = 0; i < res.results.length; i += 1) {\r\n        var error = res.results[i].error;\r\n        if (error) {\r\n            throw new ResultError(error);\r\n        }\r\n    }\r\n    return res;\r\n}\r\nexports.assertNoErrors = assertNoErrors;\r\n/**\r\n * From parses out a response to a result or list of responses.\r\n * There are three situations we cover here:\r\n *  1. A single query without groups, like `select * from myseries`\r\n *  2. A single query with groups, generated with a `group by` statement\r\n *     which groups by series *tags*, grouping by times is case (1)\r\n *  3. Multiple queries of types 1 and 2\r\n * @private\r\n */\r\nfunction parse(res, precision) {\r\n    assertNoErrors(res);\r\n    if (res.results.length === 1) {\r\n        return parseInner(res.results[0].series, precision);\r\n    }\r\n    else {\r\n        return res.results.map(function (result) { return parseInner(result.series, precision); });\r\n    }\r\n}\r\nexports.parse = parse;\r\n/**\r\n * parseSingle asserts that the response contains a single result,\r\n * and returns that result.\r\n * @throws {Error} if the number of results is not exactly one\r\n * @private\r\n */\r\nfunction parseSingle(res, precision) {\r\n    assertNoErrors(res);\r\n    if (res.results.length !== 1) {\r\n        throw new Error('node-influx expected the results length to equal 1, but ' +\r\n            (\"it was \" + 0 + \". Please report this here: https://git.io/influx-err\"));\r\n    }\r\n    return parseInner(res.results[0].series, precision);\r\n}\r\nexports.parseSingle = parseSingle;\r\n","/home/travis/build/npmtest/node-npmtest-influx/node_modules/influx/lib/src/schema.js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar grammar_1 = require(\"./grammar\");\r\n/**\r\n * The Schema provides information and utilities for an InfluxDB measurement.\r\n * @private\r\n */\r\nvar Schema = (function () {\r\n    function Schema(options) {\r\n        var _this = this;\r\n        this.options = options;\r\n        this.tagHash = {};\r\n        // fieldNames are sorted for performance: when coerceFields is run the\r\n        // fields will be added to the output in order.\r\n        this.fieldNames = Object.keys(options.fields).sort();\r\n        options.tags.forEach(function (tag) { _this.tagHash[tag] = true; });\r\n    }\r\n    /**\r\n     * coerceFields converts a map of field values to a strings which\r\n     * can be injected into the line protocol without further escaping.\r\n     * The output is given in [key, value] pairs.\r\n     */\r\n    Schema.prototype.coerceFields = function (fields) {\r\n        var _this = this;\r\n        var consumed = 0;\r\n        var output = [];\r\n        this.fieldNames.forEach(function (field) {\r\n            if (!fields.hasOwnProperty(field)) {\r\n                return;\r\n            }\r\n            var value = fields[field];\r\n            var typ = typeof value;\r\n            consumed += 1;\r\n            if (value == null) {\r\n                return;\r\n            }\r\n            var coerced;\r\n            switch (_this.options.fields[field]) {\r\n                case grammar_1.FieldType.STRING:\r\n                    coerced = grammar_1.escape.quoted(String(value));\r\n                    break;\r\n                case grammar_1.FieldType.INTEGER:\r\n                    if (typ !== 'number' && !grammar_1.isNumeric(String(value))) {\r\n                        throw new Error(\"Expected numeric value for \" + _this.ref(field) + \", but got '\" + value + \"'!\");\r\n                    }\r\n                    coerced = String(Math.floor(value)) + 'i';\r\n                    break;\r\n                case grammar_1.FieldType.FLOAT:\r\n                    if (typ !== 'number' && !grammar_1.isNumeric(String(value))) {\r\n                        throw new Error(\"Expected numeric value for \" + _this.ref(field) + \", but got '\" + value + \"'!\");\r\n                    }\r\n                    coerced = String(value);\r\n                    break;\r\n                case grammar_1.FieldType.BOOLEAN:\r\n                    if (typ !== 'boolean') {\r\n                        throw new Error(\"Expected boolean value for \" + _this.ref(field) + \", but got a \" + typ + \"!\");\r\n                    }\r\n                    coerced = value ? 'T' : 'F';\r\n                    break;\r\n                default:\r\n                    throw new Error(\"Unknown field type \" + _this.options.fields[field] + \" for \" + field + \" in \" +\r\n                        (_this.ref() + \". Please ensure that your configuration is correct.\"));\r\n            }\r\n            output.push([field, coerced]);\r\n        });\r\n        var keys = Object.keys(fields);\r\n        if (consumed !== keys.length) {\r\n            var extraneous = keys.filter(function (f) { return _this.fieldNames.indexOf(f) === -1; });\r\n            throw new Error(\"Extraneous fields detected for writing InfluxDB point in \" +\r\n                (this.ref() + \": `\" + extraneous.join('`, `') + \"`.\"));\r\n        }\r\n        return output;\r\n    };\r\n    /**\r\n     * Throws an error if the tags include values other than\r\n     * what was specified in the schema. It returns a list of tag names.\r\n     */\r\n    Schema.prototype.checkTags = function (tags) {\r\n        var _this = this;\r\n        var names = Object.keys(tags);\r\n        var extraneous = names.filter(function (tag) { return !_this.tagHash[tag]; });\r\n        if (extraneous.length > 0) {\r\n            throw new Error(\"Extraneous tags detected for writing InfluxDB point in \" +\r\n                (this.ref() + \": `\" + extraneous.join('`, `') + \"`.\"));\r\n        }\r\n        return names;\r\n    };\r\n    /**\r\n     * Returns the 'db'.'measurement'[.'field'] referencing the current schema.\r\n     */\r\n    Schema.prototype.ref = function (field) {\r\n        var out = this.options.database + '.' + this.options.measurement;\r\n        if (field) {\r\n            out += '.' + field;\r\n        }\r\n        return out;\r\n    };\r\n    return Schema;\r\n}());\r\nexports.Schema = Schema;\r\n/**\r\n * Coerces the field map to a set of writable values, a la coerceFields,\r\n * using native guesses based on the field datatypes.\r\n * @private\r\n */\r\nfunction coerceBadly(fields) {\r\n    return Object.keys(fields).sort().map(function (field) {\r\n        var value = fields[field];\r\n        if (typeof value === 'string') {\r\n            return [field, grammar_1.escape.quoted(value)];\r\n        }\r\n        else {\r\n            return [field, String(value)];\r\n        }\r\n    });\r\n}\r\nexports.coerceBadly = coerceBadly;\r\n"}